<!DOCTYPE html>
<html lang="no">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="initial-scale=1, maximum-scale=2.5, width=device-width, height=device-height">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Linux - eksamensark</title>
	<link rel="stylesheet" href="css/exam-paper.css">
	<link rel="stylesheet" href="css/exam-paper-linux.css">
	<link rel="stylesheet" href="css/katex.min.css">
	<script src="js/app.js"></script>
</head>
<body>
	<div class="wrapper">
		<section>
			<div class="row">
				<dl>
					<dt><strong class="fsl">1</strong> Viktige oppgaver</dt>
					<dd>Kommunisere med bruker og styre hardware. Fordele delte ressurser som RAM, nettverksporter, disk og printere.
					Starte og kontrollere programmer. Sikre filer og data. Tilby filsystem.</dd>

					<dt>Standard innenhet og standard utenhet</dt>
					<dd><strong>stdin</strong>: Default kilde (fil) som data leses fra. Stdin er i utgangspunktet tastaturet, eller
					egentlig den vicefilen som representerer tastaturet.</dd>
					<dd><strong>stdout</strong>: Default medium (fil) som data skrives til. Stdout er i utgangspunktet skjermen.</dd>

					<dt>Filterprogram</dt>
					<dd>Program som leser tekstlige data linje for linje fra stdin, og skriver tekstlig output linjevis til stdout.</dd>

					<dt>Redirigering av I/O.</dt>
					<dd>Tegnene '<' og '>' brukes til å redefinere hhv. stdin og stdout til å være en fil i stedet for skjermen.
					'>>' (append) gjør at utskrift til stdout legges til på slutten av en eksisterende fil.</dd>

					<dt>Piping (eller "rørlegging")</dt>
					<dd>Brukes for interprosesskommunikasjon mellom to filterprogrammer. angis med tegnet '|' mellom navnene på
					programmene. Gjør at stdout fra et filter leses som stdin fra neste filter.</dd>

					<dt>Hva er søkestien (search path) for et skall?</dt>
					<dd>En søkesti er en liste med kataloger der skallet vil lete for å finne en kommando</dd>

					<dt>Hva er navnet på skallvariabelen der søkestien lagres i Bourne-again shell?</dt>
					<dd>Søkestien ligger i systemvariabelen PATH, som inneholder en tekststreng med katalognavn adskilt med ':' (kolon).</dd>

					<dt>Nevn en fordel og en ulempe ved å bruke et GUI (grafisk grensesnitt)</dt>
					<dd>
						<dl>
							<dt>Fordeler ved GUI:</dt>
							<dd>Gjør det enklere og mer intuitivt å bruke datamaskinen. Mange brukere er vant til GUI'er (Nintendo,
							Windows, web) og arbeider lettere med pek-og-klikk verktøy.</dd>

							<dt>Ulemper ved GUI:</dt>
							<dd>Gir et "ferdigsydd" oppsett med mindre muligheter til å "skreddersy" arbeidsomgivelsene. En GUI er et
							ekstra lag med software mellom bruker og oppgavene som skal gjøres på maskinen, noe som gjør at oppgavene utføres saktere.</dd>
						</dl>
					</dd>

					<dt>Nevn en fordel og en ulempe ved å bruke et CLI (kommandolinjen)</dt>
					<dd>
						<dl>
							<dt>Fordeler ved CLI:</dt>
							<dd>Gir bedre mulighet til å kontrollere systemet og kjøre applikasjonene slik man selv ønsker. Raskt, med
							et minimalt ekstra lag med software mellom bruker og kjernen.</dd>

							<dt>Ulemper ved CLI:</dt>
							<dd>Kryptisk syntaks. Høyere inngangsterskel for nybegynnere og GUI-brukere.</dd>
						</dl>
					</dd>

					<dt>Forklar forskjellen mellom opsjoner og argumenter til en Linux-kommando.</dt>
					<dd>Opsjoner er parametre som bestemmer hvordan kommandoen skal virke. Argumenter er parametre som angir
					hvilke data kommandoen skal arbeide med, f.eks. filnavn, tall og tekststrenger.</dd>

					<dt>Hva utføres ved eksekvering av: <code>man man > man.txt</code>?</dt>
					<dd>Manualsidene til kommandoen man (manual pages) skrives til filen <code>man.txt.</code></dd>

					<dt>Hva utføres ved eksekvering av: <code>echo a*</code>?</dt>
					<dd>Navnet på alle filer i stående katalog, hvis navn begynner med en <code>a</code>, skrives ut til standard
					utenhet. Hvis det ikke finnes noen filer med navn som begynner med en <code>a</code>, skrives strengen
					<code>a*</code> ut.</dd>
				</dl>
			</div>
		</section>
		<section>
			<div class="row">
				<p>Kommandoen <code>read</code> kan brukes for å lese inn verdier fra tastaturet og lagre dem i en variabel.
				Merk at <code>read</code> er en kommando som er "innebygget" i Bash, på samme måte som <code>history</code>. For
				å se dokumentasjonen på <code>read</code>, kan du bruke kommandoen <code>help read | more</code>. Les
				dokumentasjonen for <code>read</code>, og finn ut hvordan den virker (hva skjer hvis du prøver med
				<code>man read</code>?). Skriv en Linux-kommando som spør bruker om fornavn og etternavn (bruk opsjonen
				<code>-p</code> til <code>read</code>), og leser navnene inn i to variable. Skriv deretter en Linux-kommando som,
				hvis f.eks. brukers navn er Per Hansen, skriver ut på skjermen "Hællæ, Per Hansen".<br>
				<code>read -p "Tast inn fornavn og etternavn: " fornavn etternavn</code><br>
				<code>echo "Hællæ, $fornavn $etternavn"</code></p>

				<hr>
				<p>Opprett en ny fil med navn <code>testprogram</code> med en teksteditor. Legg inn de to kommandoene du skrev i
				forrige oppgave på hver sin linje i denne filen. Lagre filen og gå tilbake til shellet. Gi kommandoen:
				<code>bash testprogram</code>. Hva skjer? Det startes et nytt subshell som leser og utfører de to kommandoene
				som er lagret på filen (som er et skallprogram/shellscript). Deretter terminerer subshellet og kontrollen går
				tilbake til innloggings-shellet.</p>
			</div>
			<div class="row">
				<dl>
					<dt>Hvilke filtyper har vi i Linux?</dt>
					<dd>
						<ul class="nostyle inline">
							<li>Regulære filer (regular/ordinary files)</li>
							<li>Kataloger (directory files)</li>
							<li>Spesialfiler (links, devices, pipes,...)</li>
						</ul>
					</dd>

					<dt>Hva er et inode-nummer i filsystemet til Linux?</dt>
					<dd>Inoden er en datastruktur i et Unix-stil-filsystem som beskriver et filsystemobjekt som en fil eller en
					katalog. Hver inode lagrer attributter og diskblokkposisjon(er) til objektets data. Attributter for
					filsystemsobjekter kan inneholde metadata som tider for siste endring og tilgang, samt eier- og tillatelsesdata.
					Kataloger er lister over navn som er tilordnet inoder. En katalog inneholder en oppføring for seg selv, sin
					forelder og hver av sine barn.</dd>

					<dt>Hva inneholder <em>egentlig</em> en katalogfil?</dt>
					<dd>En katalogfil inneholder en liste med ett element for hver fil (inkludert katalogfiler) i katalogen. Et
					element i en katalogfil kalles for en <em>hard link</em> og består av filens inode-nummer og filnavn.</dd>

					<dt>Hvordan kan vi skille en ordinær fil fra en katalogfil ved hjelp av kommandoen <code>ls</code>?</dt>
					<dd>Bruk <code>ls -l</code>, første tegn på linjen for hver fil angir da filtype, <code>d</code> for
					katalogfil, <code>-</code> for ordinær fil. Evt. kan <code>ls -F</code> brukes, da angis filtypene med et
					spesialtegn (og fargekoding i noen versjoner av <code>ls</code>) etter filnavnene.</dd>

					<dt>Skriv en Linux-kommando som skriver ut innholdet av alle filer i stående katalog som har et filnavn som
					slutter med <code>.txt</code>.</dt>
					<dd><code>cat *.txt</code></dd>

					<dt>(Symbolic links) For å se i praksis hvordan lenker virker, gjør følgende:</dt>
					<dd>
						<dl>
							<dt>Opprett en fil med navn abcd.txt som inneholder et par linjer med tekst.</dt>
							<dd><code>nano/emacs/vim abcd.txt</code></dd>

							<dt>Bruk <code>ln</code> til å lage en hard lenke med navn <code>abcd_hard.txt</code> og en symbolsk lenke
							med navn <code>abcd_soft.txt</code>, som begge peker til filen <code>abcd.txt</code>.</dt>
							<dd><code>ln abcd.txt abcd_hard.txt</code><span class="i5"><code>ln -s abcd.txt abcd_soft.txt</code></span></dd>

							<dt>Skriv ut innholdet av tekstfilen og av begge lenkene med <code>cat</code>, for å verifisere at de
							refererer til samme datafil.</dt>
							<dd><code>cat abcd.txt</code>, <code>cat abcd_soft.txt</code>, <code>cat abcd_hard.txt</code>, </dd>

							<dt>Skriv ut inodenummerne til tekstfilen og til de to lenkene, med <code>ls -i</code>. Hva ser du?</dt>
							<dd>Hvis det er flere hard-links til samme fil, vil de ha samme inode-nummer. Filen lagres bare ett sted,
							men det kan være flere katalogfiler med hard-links som peker til samme fil.</dd>

							<dt>Skriv ut informasjon om bl.a. filtype, størrelse og antall (harde) lenker for tekstfilen og de to
							lenkene, med <code>ls -l</code>. Hva ser du?</dt>
							<dd>Det to hard-linkene har samme filinformasjon, og viser at det er to hard-links til filen. Soft-linken
							er en egen fil med eget inode-nummer og størrelse lik antall bytes i den symbolske linken.</dd>

							<dt>Fjern tekstfilen <code>abcd.txt</code>. Prøv deretter å skrive ut innholdet av både den harde og den
							symbolske lenken. Hva skjer, og hvorfor?</dt>
							<dd>Den symbolske lenken virker ikke lenger, fordi filnavnet den lenker til er fjernet. Filen i seg selv
							fjernes ikke, fordi det fortsatt finnes en hard-link til den.</dd>
						</dl>
					</dd>
				</dl>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section class="w4">
			<div class="row">
				<h1><strong class="fsl">2</strong> Kommandoer</h1>
				<table>
					<thead>
						<tr>
							<th>Hvordan...</th>
							<th>Kommando</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><b>Elementær navigering</b></td>
						</tr>
						<tr>
							<td>får jeg mer info om en kommando?</td>
							<td>man &lt;kommando&gt;<br>&lt;kommando&gt; --help</td>
						</tr>
						<tr>
							<td>lister jeg filer i en katalog?</td>
							<td>ls</td>
						</tr>
						<tr>
							<td>skifter jeg katalog?</td>
							<td>cd &lt;katalog&gt; </td>
						</tr>
						<tr>
							<td>vet jeg i hvilken katalog jeg er?</td>
							<td>pwd</td>
						</tr>
						<tr>
							<td>oppretter/fjerner jeg en katalog?</td>
							<td>mkdir/rmdir &lt;katalog&gt; </td>
						</tr>
						<tr>
							<td>kopierer jeg en fil?</td>
							<td>cp </td>
						</tr>
						<tr>
							<td>sletter jeg en fil?</td>
							<td>rm</td>
						</tr>
						<tr>
							<td>lager jeg en (tom) fil?</td>
							<td>touch</td>
						</tr>
						<tr>
							<td>flytter jeg en fil/endrer navn på fil</td>
							<td>mv</td>
						</tr>
						<tr>
							<td>lister jeg innholdet i en fil?</td>
							<td>cat / more / less</td>
						</tr>
						<tr>
							<td>får jeg opp informasjon om diskbruk?</td>
							<td>df</td>
						</tr>
						<tr>
							<td>sjekker jeg hvor mye diskplass brukt?</td>
							<td>du -sh</td>
						</tr>
						<tr>
							<td>sjekker jeg ledig minne?</td>
							<td>free</td>
						</tr>
						<tr>
							<td>finner jeg en spesifikk fil?</td>
							<td>find / whereis &lt;fil&gt;</td>
						</tr>
						<tr>
							<td>lager jeg en snarvei?</td>
							<td>ln -s &lt;faktisk_fil&gt; &lt;snarvei&gt;</td>
						</tr>
						<tr>
							<td>pakker jeg inn/ut filer?</td>
							<td>gzip/bunzip / tar</td>
						</tr>
						<tr>
							<td><b>Bruker-relaterte kommandoer</b></td>
						</tr>
						<tr>
							<td>vet jeg hvem jeg er?</td>
							<td>whoami</td>
						</tr>
						<tr>
							<td>logger jeg meg inn som root?</td>
							<td>su</td>
						</tr>
						<tr>
							<td>endrer jeg passord?</td>
							<td>passwd</td>
						</tr>
						<tr>
							<td>får jeg opp diverse info om systemet?</td>
							<td>w</td>
						</tr>
						<tr>
							<td>finner jeg ut mer om en bruker?</td>
							<td>finger</td>
						</tr>
						<tr>
							<td>endrer jeg rettigheter på filer?</td>
							<td>chmod</td>
						</tr>
						<tr>
							<td>endrer jeg eierskap på filer?</td>
							<td>chown</td>
						</tr>
						<tr>
							<td>legger jeg til bruker?</td>
							<td>useradd</td>
						</tr>
						<tr>
							<td>endrer jeg mitt shell?</td>
							<td>chsh</td>
						</tr>
						<tr>
							<td><b>Enkle nettverkskommandoer</b></td>
						</tr>
						<tr>
							<td>sjekker jeg om en boks er på nett?</td>
							<td>ping</td>
						</tr>
						<tr>
							<td>konfigurerer jeg nettverket?</td>
							<td>ifconfig</td>
						</tr>
						<tr>
							<td>bruker jeg traceroute?</td>
							<td>traceroute</td>
						</tr>
						<tr>
							<td>snakker jeg med andre som er innlogget?</td>
							<td>talk</td>
						</tr>
						<tr>
							<td><b>Mer avanserte kommandoer</b></td>
						</tr>
						<tr>
							<td>finner jeg ut hvilken linux-ver jeg har?</td>
							<td>uname<br>
								cat /proc/version</td>
						</tr>
						<tr>
							<td>får jeg tilgang til andre disker?</td>
							<td>mount</td>
						</tr>
						<tr>
							<td>formaterer jeg en disk?</td>
							<td>mkfs</td>
						</tr>
						<tr>
							<td>sjekker jeg om en disk er skadet?</td>
							<td>fsck</td>
						</tr>
						<tr>
							<td>lister jeg alle prosesser?</td>
							<td>ps</td>
						</tr>
						<tr>
							<td>lister jeg alle prosesser i en fin tabell?</td>
							<td>top</td>
						</tr>
						<tr>
							<td>avslutter (dreper) jeg en prosess?</td>
							<td>kill</td>
						</tr>
						<tr>
							<td>slår jeg av boksen?</td>
							<td>shutdown</td>
						</tr>
						<tr>
							<td>partitionerer jeg en disk?</td>
							<td>fdisk</td>
						</tr>
						<tr>
							<td>viser jeg all oppstarts-info?</td>
							<td>dmesg</td>
						</tr>
						<tr>
							<td>aktiverer jeg shadow passord?</td>
							<td>pwconv</td>
						</tr>
						<tr>
							<td>lister hvilke moduler som er lastet?</td>
							<td>lsmod</td>
						</tr>
						<tr>
							<td><b>Annet</b></td>
						</tr>
						<tr>
							<td>sjekker jeg hvilket skjermkort jeg har?</td>
							<td>SuperProbe</td>
						</tr>
						<tr>
							<td>konfigurerer jeg X?</td>
							<td>xf86config</td>
						</tbody>
						</tr>
				</table>
			</div>
		</section>
		<section class="w6">
			<div class="row">
				<h1>Forklaring</h1>
				<h2>Elementær navigering:</h2>
				<dl>
					<dt><h2>ls</h2></dt>
					<dd>Brukes for å bytte <em>working directory</em></dd>
					<dd><code>ls [options] [file|dir]</code></dd>
					<dd>
						<table class="table-code">
							<tbody>
								<tr>
									<td>ls -a</td>
									<td>list all files including hidden file starting with '.'</td>
								</tr>
								<tr>
									<td>ls --color</td>
									<td>colored list [=always/never/auto]</td>
								</tr>
								<tr>
									<td>ls -d</td>
									<td>list directories - with ' */'</td>
								</tr>
								<tr>
									<td>ls -F</td>
									<td>add one char of */=&gt;@| to enteries</td>
								</tr>
								<tr>
									<td>ls -i</td>
									<td>list file's inode index number</td>
								</tr>
								<tr>
									<td>ls -l</td>
									<td>list with long format - show permissions</td>
								</tr>
								<tr>
									<td>ls -la</td>
									<td>list long format including hidden files</td>
								</tr>
								<tr>
									<td>ls -lh</td>
									<td>list long format with readable file size</td>
								</tr>
								<tr>
									<td>ls -ls</td>
									<td>list with long format with file size</td>
								</tr>
								<tr>
									<td>ls -r</td>
									<td>list in reverse order</td>
								</tr>
								<tr>
									<td>ls -R</td>
									<td>list recursively directory tree</td>
								</tr>
								<tr>
									<td>ls -s</td>
									<td>list file size</td>
								</tr>
								<tr>
									<td>ls -S</td>
									<td>sort by file size</td>
								</tr>
								<tr>
									<td>ls -t</td>
									<td>sort by time & date</td>
								</tr>
								<tr>
									<td>ls -X</td>
									<td>sort by extension name</td>
								</tr>
								<tr>
									<td><strong>Eks</strong></td>
									<td></td>
								</tr>
								<tr>
									<td>ls ~cathrineb</td>
									<td>Skriver ut innholdet i hjemmekatalogen til brukeren cathrineb (hvis du har lesetilgang til denne katalogen).</td>
								</tr>
								<tr>
									<td>ls -ld h*</td>
									<td>Skriver ut, i langt format (opsjonen '-l), informasjon om alle katalogfiler/underkataloger
									(opsjonen '-d) i stående katalog med navn som begynner på 'h'. Innholdet i katalogene skrives ikke ut.</td>
								</tr>
							</tbody>
						</table>
					</dd>

					<dt><h2>cd</h2></dt>
					<dd>Brukes for å bytte <em>working directory</em></dd>
					<dd><code>cd [option] [directory]</code></dd>

					<dt>pwd</dt>
					<dd>Viser i hvilken katalog som bruker befinner seg i.</dd>
					<dd>
						<dl>
							<dt>Eksempel</dt>
							<dd>
<pre class="fss">
[bruker@pc /]$ cd ~
[bruker@pc ~]$ pwd
/home/bruker
</pre>
							</dd>
						</dl>
					</dd>

					<dt>mkdir/rmdir</dt>
					<dd>Disse kommandoene oppretter/fjerner kataloger. NB! Katalogen må være tom før du får slettet den med denne kommandoen.</dd>

					<dt><h2>cp</h2></dt>
					<dd>Brukes for å kopiere filer og/eller kataloger</dd>
					<dd><code>cp [options] source dest</code></dd>
					<dd>
						<table class="table-code">
							<tbody>
								<tr>
									<td>cp -r</td>
									<td>Copy recursively</td>
								</tr>
							</tbody>
						</table>
					</dd>

					<dt><h2>mv</h2></dt>
					<dd>Brukes for å flytte filer og/eller kataloger</dd>
					<dd>Kan også brukes for å endre navn på filer eller kataloger</dd>
					<dd><code>mv [options] source dest</code></dd>
					<dd>
						<table class="table-code">
							<tbody>
								<tr>
									<td>mv -f</td>
									<td>force move by overwriting destination file without prompt</td>
								</tr>
								<tr>
									<td>mv -i</td>
									<td>interactive prompt before overwrite</td>
								</tr>
								<tr>
									<td>mv -u</td>
									<td>update - move when source is newer than destination</td>
								</tr>
								<tr>
									<td>mv -v</td>
									<td>verbose - print source and destination files</td>
								</tr>
							</tbody>
						</table>
					</dd>
					<dd>
						<strong>Eksempler</strong>
						<dl>
							<dt><code>[bruker@pc ~]$ mv testfil katalog1/</code></dt>
							<dd>Vi flytter filen testfil1 til katalog1/</dd>

							<dt><code>[bruker@pc ~]$  mv testfil nyttnavn</code></dt>
							<dd>Vi "flytter" filen til ett annet navn.</dd>
						</dl>
					</dd>
				</dl>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<dl>
					<dt><h2><strong class="fsl">3</strong> alias</h2></dt>
					<dd>Brukes for å lage aliaser til kommandoer</dd>
					<dd><code>alias [-p] [name[=value] ... ]</code></dd>
					<dd>
						<table class="table-code">
							<tbody>
								<tr>
									<td>alias -p [name[=value] ...]</td>
									<td>print all defined aliases in a reusable format</td>
								</tr>
								<tr>
									<td><strong>Eks</strong></td>
									<td></td>
								</tr>
								<tr>
									<td>alias harakiri 'rm -r'</td>
									<td>Definerer et kommandoalias med navn harakiri, som skal fjerne alle filer i stående katalog og alle
									underkataloger av stående katalog.</td>
								</tr>	
							</tbody>
						</table>
					</dd>

					<dt><h2>rm</h2></dt>
					<dd>Brukes for å slette filer og/eller kataloger</dd>
					<dd><code>rm [OPTION]... FILE...</code></dd>
					<dd>
						<table class="table-code">
							<tbody>
								<tr>
									<td>-f, --force</td>
									<td>Ignore nonexistant files, and never prompt before removing.</td>
								</tr>
								<tr>
									<td>-i</td>
									<td>Prompt before every removal.</td>
								</tr>
								<tr>
									<td>-I</td>
									<td>Prompt once before removing more than three files, or when removing recursively. Less intrusive than -i, while still giving protection against most mistakes.</td>
								</tr>
								<tr>
									<td>--interactive[=<em>WHEN</em>]</td>
									<td>Prompt according to <em>WHEN</em>: never, once (-I), or always (-i). If <em>WHEN</em> is not specified, then prompt always.</td>
								</tr>
								<tr>
									<td>--one-file-system</td>
									<td>When removing a hierarchy recursively, skip any directory that is on a file system different from that of the corresponding command line argument</td>
								</tr>
								<tr>
									<td>--no-preserve-root</td>
									<td>Do not treat "/" (the root directory) in any special way.</td>
								</tr>
								<tr>
									<td>--preserve-root</td>
									<td>Do not remove "/" (the root directory), which is the default behavior.</td>
								</tr>
								<tr>
									<td>-r, -R, --recursive</td>
									<td>Remove directories and their contents recursively.</td>
								</tr>
								<tr>
									<td>-v, --verbose</td>
									<td>Verbose mode; explain at all times what is being done.</td>
								</tr>
								<tr>
									<td>--help</td>
									<td>Display a help message, and exit.</td>
								</tr>
								<tr>
									<td>--version</td>
									<td>Display version information, and exit.</td>
								</tr>
								<tr>
									<td><strong>Eks</strong></td>
									<td></td>
								</tr>
								<tr>
									<td>rm -rf firefox/cache/*</td>
									<td>Fjerner alle filer som brukeren er eier av (uansett filbeskyttelse) i hele katalogtreet med rot i
									underkatalogen ./firefox/cache/ .</td>
								</tr>
								<tr>
									<td>rm -f ~/personal/memo*.doc</td>
									<td>Fjerner alle filer som ligger i katalogen personal med filnavn som starter med memo og slutter med
									.doc</td>
								</tr>
								<tr>
									<td>rm -f ~/linuxbook/final/ch??.prn</td>
									<td>Fjerner alle filer som ligger i katalogen final, som er en underkatalog av linuxbook, med filnavn
									på åtte tegn som starter med ch, etterfulgt av to vilkårlige tegn, og deretter slutter med .prn</td>
								</tr>
								<tr>
									<td>rm -f ~/linuxbook/final/*.o</td>
									<td>Fjerner alle filer som ligger i katalogen final, som er en underkatalog av linuxbook, med filnavn
									som slutter med .o</td>
								</tr>
								<tr>
									<td>rm -f ~/courses/ece446/lab[1-6].[cC]</td>
									<td>Fjerner alle filer som ligger i katalogen ece446, som er en underkatalog av courses, med filnavn
									på 6 tegn som starter med lab, etterfulgt av ett av sifrene 1-6, og deretter slutter med .c eller .C</td>
								</tr>
							</tbody>
						</table>
					</dd>

					<dt><h2>cat</h2></dt>
					<dd>Brukes for å vise innholdet i en fil</dd>
					<dd>Cat kommandoen er meget nyttig. Cat har flere funksjoner, men elementært, så leser den en fil og viser den til "standard output". Kort (og grovt) fortalt, kan vi si at kommadoen henter ett filformat og "kaster" den til riktig utgang. F.eks. kan vi "kaste" en musikk-fil til lydkortet (og dermed få lyd), eller en fil til printerporten (og printe ut noe).</dd>
					<dd><code>cat [options] file1 [file2...]</code></dd>
					<dd>
						<table class="table-code">
							<tbody>
								<tr>
									<td>cat -b</td>
									<td>add line numbers to non blank lines</td>
								</tr>
								<tr>
									<td>cat -n</td>
									<td>add line numbers to all lines</td>
								</tr>
								<tr>
									<td>cat -s</td>
									<td>squeeze blank lines to one line</td>
								</tr>
								<tr>
									<td>cat -E</td>
									<td>show $ at the end of line</td>
								</tr>
								<tr>
									<td>cat -T</td>
									<td>show ^I instead of tabs</td>
								</tr>
								<tr>
									<td><strong>Eks</strong></td>
									<td></td>
								</tr>
								<tr>
									<td>cat < fil_1 >> fil_2</td>
									<td>fil_1 legges til på slutten av fil_2</td>
								</tr>
								<tr>
									<td class="wrap">cat < kapittel_1.txt | tee kapittel_1.txt.backup | lpr</td>
									<td>En kopi av filen kapittel_1.txt lagres på filen kapittel_1.txt.backup. kapittel_1.txt sendes også
									til utskrift på default printer.</td>
								</tr>
							</tbody>
						</table>
					</dd>

				</dl>
			</div>
		</section>
		<section>
			<div class="row">
				<dl>
					<dt>df -h</dt>
					<dd>Viser hvor mye ledig diskplass som er ledig. Ved bruk av df -h gir det en litt mer leslig format (megabyte, kilobyte etc.). Eks:</dd>
					<dd>
<pre class="fss">
[bruker@pc ~]$ df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            3,8G     0  3,8G   0% /dev
tmpfs           783M   11M  773M   2% /run
/dev/nvme0n1p2  234G   56G  167G  25% /
</pre>
					</dd>
					<dt>du -sh</dt>
					<dd>Viser hvor mye plass stående katalogen (med underkataloger) tar av diskplass. Eks:</dd>
					<dd>
<pre class="fss">
[bruker@pc ~]$ pwd
/home/bruker
[bruker@pc ~]$ dh -sh
35.6G    .
[bruker@pc ~]$ cd testmappe
[bruker@pc testmappe]$ pwd
/home/bruker/testmappe
[bruker@pc testmappe]$ dh -sh
2.1M     .
</pre>
					</dd>

					<dt>free</dt>
					<dd>Viser hvor systemets bruk av minne. "free -m" viser minnebruken i megabytes.</dd>

					<dt>find / whereis</dt>
					<dd>Den første kommandoen, find, leter gjennom de kataloger som er eksportert til bash. Den andre kommandoen, whereis, er leter mer omfattende. Se også kommandoen, locate for mer avansert filsøking.</dd>

					<dt>ln</dt>
					<dd>Filer kan ha flere navn i UNIX/Linux. Dette gjøres ved kommandoen ln. Du oppretter da en snarvei til den faktiske filen.</dd>
					<dd><code>[bruker@pc testmappe]$ ln /mappe/undermappe/filen /home/bruker/snarvei</code></dd>
					<dt></dt>
					<dd>Oppretter her en snarvei, kalt "snarvei", som peker på filen "/mappe/undermappe/filen"</dd>

					<dt>gzip / bzip2</dt>
					<dd>For å pakke ned en fil, brukes kommandoen:</dd>
					<dd>
						<dl>
							<dt><code>[bruker@pc ~]$ gzip en_fil</code></dt>
							<dd>"en_fil" vil da bli pakket ned, og den pakkede filen får navn "en_fil.gz". Merk! "en_fil.gz" erstatter "en_fil"! Du får dermed kun en kopi av den pakkede filen!</dd>

							<dt><code>[bruker@pc ~]$ gzip -9 en_fil</code></dt>
							<dd>Ved å bruke -9, vil det si at vi bruker maksimal kompresjon. Ved å bruke lavere tall, vil det ta kortere tid å pakke ned, men den pakkede filen vil bli større.</dd>
						</dl>
						<dd>For å pakke ut en fil brukes følgende kommando:</dd>
						<dl>
							<dt><code>[bruker@pc ~]$ gunzip en_fil.gz</code></dt>
							<dd>bzip2 er en forbedret utgave av gzip. Den bruker en litt annen komprimerings-algoritme, og får pakket ned filer bedre. Den bruke på samme måte som gzip/gunzip, bare at det er bzip2/bunzip2. De pakkede filene vil få navn som "en_fil.bz2". Se man sidene for mer avansert bruk av gzip/bzip2.</dd>
						</dl>
					</dd>

					<dt>tar</dt>
					<dd>Tar ble opprinnlig brukt til backup. Legger alle filer og kataloger i en stor fil, som det igjen ble tatt backup av. Det fine med tar, er at du kan pakke ned hele katalogstrukturer, noe som ikke går med gzip/bzip2. Ofte er tar brukt til først å pakke ned i en stor fil, også pakket med gzip. Dissse filene har ending .tar.gz, også kalt "tarball". Eldre slike filer kan også ha ending .tar.Z. Det er også .tar.gz2 filer, som pakket med tar og pakket ned med gzip. Kernelkildekoden er pakket på denne måten. Pakker ut en tarball med følgende kommando:</dd>
					<dd>
						<dl>
							<dt><code>[bruker@pc ~]$ tar zxfv backupavfil.tar.gz</code></dt>
							<dd>Igjen, for mer (masse) informasjon om bruk, se man sidene.</dd>
						</dl>
					</dd>

					<dt>passwd</dt>
					<dd>Gjør at du skifter passord. Denne kommandoen skifter kun passord på din lokale maskin. Merk! Hvis det er et nettverk, er det mest sannsynlig "yppasswd" ("yp on lan" eller "Yellow Pages on Local Area Network"). Root kan selvfølgelig skifte passord på hvem han selv måtte ønske ("passwd lars").</dd>
					<dd>Root kan også stenge en konto ved å bruke følgende kommando:</dd>
					<dd><code>[bruker@pc ~]$ passwd -l lars</code></dd>
					<dd>Passordet for denne kontoen settes da til noe ugjettbart :) For å låse opp denne kontoen bruker vi kommandoen:</dd>
					<dd><code>[bruker@pc ~]$ passwd -u lars</code></dd>
				</dl>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<dl>
					<h2><strong class="fsl">4</strong> Bruker-relaterte kommandoer:</h2>

					<dt>chmod</dt>
					<dd>Linux/Unix har et innfløkt (men logisk) system for filtildeling. Filtildeinger gis ved kommadoen chmod.</dd>
					<dd>
						<dl>
							<dt>Først litt teori:</dt>
							<dd>Eks: Ved å skrive ls -l kommer følgende opp:</dd>
							<dd>
<pre class="fss">
[bruker@pc ~]$ ls -l
-rw-rw-r-- 1 bjornar bjornar     0 nov.   8 15:13 a.out
lrwxrwxrwx 1 bjornar bjornar    20 okt.  27 01:37 bin -> .dotfiles/common/bin
lrwxrwxrwx 1 bjornar bjornar    22 okt.  27 01:37 crontab -> .dotfiles/cron/crontab
drwxr-xr-x 2 bjornar bjornar  4096 nov.  15 13:54 Desktop
drwxr-xr-x 5 bjornar bjornar  4096 nov.  29 12:09 Documents
drwxr-xr-x 2 bjornar bjornar  4096 des.   4 11:52 Downloads
drwx------ 9 bjornar bjornar  4096 des.   5 10:36 Drive
drwxr-xr-x 2 bjornar bjornar  4096 okt.  27 01:31 Music
drwxr-xr-x 3 bjornar bjornar  4096 nov.   7 13:58 Pictures
drwxr-xr-x 2 bjornar bjornar  4096 okt.  27 01:31 Templates
drwxr-xr-x 3 bjornar bjornar  4096 okt.  27 17:04 Videos
lrwxrwxrwx 1 bjornar bjornar    20 okt.  27 01:37 .vimrc -> .dotfiles/vim/.vimrc
-rw-r--r-- 1 bjornar users     165 okt.  30 11:10 .wget-hsts
</pre>
							</dd>
							<dd>La oss se på den første kolonnen til den siste filen her... (.wget-hsts)</dd>
							<dd class="fsm"><strong><span class="purple">-</span><span class="blue">rw-</span><span class="red">r--</span><span class="green">r--</span></strong> bjornar users 165 okt...</dd>
							<dd>Det første tegnet er <span class="purple">-</span>, sier hva slags fil dette er (<code>d</code> for kataloger,
							<code>c</code> for enheter osv.). Videre er det 3 tegn <span class="blue">rw-</span> + 3 tegn <span class="red">r--</span>
							+ 3 tegn <span class="green">r--</span> = 3 x 3. Tilsammen 10 tegn. La oss forklare hvert segment (hver farge).</dd>
							<dd>
								<dl>
									<dt>Blå</dt>
									<dd>De første tre symbolene er filtildelingene for de som eier filene (i dette tilfelle ser vi at der et bjornar). Dette første segmentet kalles "u" for "user".</dd>

									<dt>Rød</dt>
									<dd>De neste tre symbolene er tilganger for gruppe (i dette tilfellet "users" - Hvis jeg hadde vært i f.eks. gruppen "frisurf", så kunne jeg gitt tilganger til andre som var i min gruppe (dvs. "frisurf"). Andre grupper, f.eks. "total" ville ikke ha hatt de samme tilganger.). Kalt segment "g" for "group".</dd>

									<dt>Grønn</dt>
									<dd>De tre siste symbolene er tilganger for alle andre (dvs. hvemsomhelst). Kalles semgent "o" for "other".</dd>
								</dl>
							</dd>
						</dl>
					</dd>
					<dd>
						<dl>
							<dt>Rettigheter</dt>
							<dd>r = read</dd>
							<dd>w = write</dd>
							<dd>x = execute (NB! For å få tilgang til kataloger, må de ha tilgang til å bli eksekverbare)</dd>

							<dt>Hvordan endre rettigheter?</dt>
							<dd>1, Du angir først hvem endringen skal gjelde for (enten user, group eller other). </dd>
							<dd>2. Deretter + eller - </dd>
							<dd>3. Tilslutt hva slags rettigheter som skal settes (som er read, write eller execute)</dd>

							<dt>Eksempeler</dt>

							<dl>
								<dt><code>[bruker@pc ~]$ chmod o+rw test.txt</code></dt>
								<dd>Denne kommandoen vil gi lese (r) og skrive (w) til alle andre (other) for filen test.txt</dd>

								<dt><code>[bruker@pc ~]$ chmod o-rw test.txt </code></dt>
								<dd>Dette gjør det motsatte, nemlig å fjerne lese og skrive rettigheter for filen test.txt for alle andre (other).</dd>

								<dt><code>[bruker@pc ~]$ chmod go-x lars/</code></dt>
								<dd>Gjør at jeg sperrer katalogen lars/ for både min gruppe (group) og alle andre (other). Som bruker har jeg fremdeles mine tilganger inntakt (user).</dd>
							</dl>
						</dl>
					</dd>

					<dt>chown < bruker:gruppe > < fil/katalog ></dt>
					<dd>Selv om rettighetene er i orden, så forutsetter det at bruker eier filen/katalogen. Merk! Det er kun root som kan skifte eierskap av filer/kataloger. Eks:</dd>
					<dd><code>[bruker@pc ~]$ chown brev.txt liuns</code></dd>
					<dd>Jeg gir bruker "linus" eierskap til filen "brev.txt".</dd>
					<dd><code>chown root:mygroup /usr/local/folder -R</code></dd>
					<dd>Alle filer og undermapper i /usr/local/folder blir nå eid av bruker root og gruppen mygroup</dd>
				</dl>
			</div>
		</section>
		<section>
			<div class="row">
				<dl>
					<dt>finger < en_bruker ></dt>
					<dd>Er en kommando som kan brukes til å få opp informasjon om en bruker på systemet. Hvis brukeren har en .plan og/eller .project med utfyllende beskrivelse, kan en annen bruker få opp denne informasjonen ved å bruker finger < bruker >. NB! Denne tjenesten kan være utilgjengelig på enkelte systemer, dette fordi system-administratoren har gjort dette av sikkerhetshensyn. Prøv å skriv:</dd>
					<dd><code>[bruker@pc ~]$ finger volkerdi@slackware.com</code></dd>
					<dd>Som gjør at du får opp finger kommandoer om Patrick Volkerding; mannen bak Slackware.</dd>
					<dd>eller</dd>
					<dd><code>[bruker@pc ~]$ finger johnc@idsoftware.com</code></dd>
					<dd>Med denne kommandoen får du opp informasjon om John Carmack - mannen bak alle grafikk-motorene til ID Software. Carmack pleier å ha mye oppdatert informasjon om grafikk-kort og fremtdige prosjekter til ID Software.</dd>
					<dd>eller</dd>
					<dd><code>[bruker@pc ~]$ finger larstra@ifi.uio.no</code></dd>

					<dt>useradd </dt>
					<dd>Kommando for å legge til brukere.</dd>
					<dd><code>[bruker@pc ~]$ useradd ola -p ola42 -d /home/ola -m</code></dd>
					<dd>Legger til ola-bruker med passord "ola42", og med hjemmekatalog under /home/ola. Se man useradd for mer info. Ofte følger det med egne "useradd"-script for hver distribusjon; "adduser" i Slackware, "YaSt" i Suse osv. KDE har også ett eget grafisk bruker administrasjons program.</dd>

					<dt>userdel</dt>
					<dd>Fjerner bruker fra systemet.</dd>
					<dd><code>[bruker@pc ~]$ userdel -r ola</code></dd>
					<dd>Fjerner brukeren ola fra systemet. Sletter samtidig hjemmekatalogen.</dd>

					<dt>chsh</dt>
					<dd>Hvis brukeren har lyst til å endre sitt shell, gjøres det med denne kommandoen. Ulike shell kan dekke ulike behov. Sjekk først hvilke shell som er tilgjenglig i filen "/etc/shells". Les mer om shell under ordliste.</dd>

					<h2>Enkle nettverkskommandoer:</h2>

					<dt>ping</dt>
					<dd>Dette er noe av den enkleste nettverkskommandoen. Det denne kommandoen gjør, er å se om en annen burk på er på nettverket. Denne kommandoen kan også brukes for å se om du har nettverks-trafikk overhode. Prøve f.eks.</dd>
					<dd><code>[bruker@pc ~]$ ping www.online.no</code></dd>

					<dt>ifconfig </dt>
					<dd>Denne kommandoen konfigurerer ett nettverks-"interface". Eks:</dd>
					<dd><code>[bruker@pc ~]$ ifconfig eth0 10.1.1.2 broadcast 10.1.1.255 netmask 255.255.255.0</code></dd>
					<dd>Denne setter opp eth0, som er vårt første nettverkskort (og eneste, hvis vi kun har ett kort i boksen), til å bruke IP-adresse 10.1.1.2. Videre broadcaster den til hele 10.1.1 subnettet. Du kan nesten alltid bruke netmaske 255.255.255.0. Hvis du vil bruke andre instillinger, vet du nok allerede nok om denne slags konfigurasjonen :) Sjekk man sidene for mer informasjon.</dd>
					<dd>Denne kommandoen kan også få opp generell informasjon om interfacet ved kun å skrive "ifconfig".</dd>

					<dt>traceroute</dt>
					<dd>Viser veien nettverks-pakkene må gå for å komme frem til en destinasjonen. Prøv f.eks.</dd>
					<dd><code>[bruker@pc ~]$ traceroute www.uio.no</code></dd>

					<dt>talk</dt>
					<dd>talk < bruker >, åpen er en enkel snakke-kanal med en annne bruker. Den du prøver å snakke med må også skrive talk < bruker > for at forbindelsen skal oppnås.</dd>

				</dl>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<dl>
					<h2><strong class="fsl">5</strong> Mer avanserte kommandoer:</h2>

					<dt>mount</dt>
					<dd>Avgjør hva som kan aksesseres. Alle harddisker blir mountet til filer (kataloger) under Linux. Faktisk så er alle enhetene i maskinen filer under Linux. Les mer om dette her. En harddisk, cd-rom, diskettstasjon, må "mountes" før de kan aksesseres. Det er to måter å mounte filsystemer på: vanskelig og enkel.
					Vanskelig: Når en enhet mountes, må vi vite all relevant informasjon om filsystemet, som vi så plotter inn til en kommando. 
					Kommandoen blir noe slikt: mount < option > enhet < katalog >. La oss belyse med ett eksempel; mounting av en CD-ROM:</dd>
					<dd><code>[bruker@pc ~]$ mount -t iso9660 -o ro /dev/hdc /cdrom</code></dd>
					<dd>Det å måtte tast inn dette hver gang vi skal ha tilgang til cdrom'en blir fort kjedelig, derfor ser vi nærmere på den enkle måten..</dd>
					<dd>Enkel: En enkelt måte å slippe å gjøre dette hver gang vi skal få tilgang til cd-romen er å legge all denne informasjonen inn i /etc/fstab. Som det meste annet i Linux, er også denne filen en ren tekst fil. Slik kan en /etc/fstab fil se ut:</dd>
					<dd>
<pre class="fss">
[bruker@pc ~]$ cat /etc/fstab
/dev/sda1   /            ext2     defaults           1   1
/dev/sda2   /usr/local   ext2     defaults           1   2
/dev/sda3   /home        ext2     defaults           1   2
/dev/sda4   swap         swap     defaults           0   0
none        /dev/pts     devpts   gid=5,mode=620     0   0
none        /proc        proc     defaults           0   0
/dev/fd0    /mnt/floppy  vfat     defaults           0   0
/dev/cdrom  /cdrom       iso9660  user, ro, noauto   0   0
</pre>
					</dd>
					<dd>Den første kolonnen viser hvilken "enhet" (device fil) det er snakk om. Neste kolonne viser hvilken katalog denne enheten skal mountes til. Det neste er hvilket filsystem som denne enheten har, i vårt tilfelle er det standard cdrom-format (iso9660). Så kommer kolonnen som viser diverse spesifikasjoner som kan brukes under mounting; "user" vil si at andre brukere enn root kan mounte denne enheten, den er kun lesbar "ro", og den skal ikke mountes under oppstart "noauto".</dd>
					<dd>De to siste kolonnen er av mindre interesse, men det kan være greit å vite hva de står for: Den nest siste kolonnen, kalt "dump flag", sier om denne enheten skal det bli tatt backup av. Den siste kolonnen, "check sequence", avgjør hvordan systemet skal sjekke filsystemene under oppstart. Root disken skal alltid ha verdi 1, andre disker skal ha verdi 2. Swap og andre disker skal ha verdi 0.</dd>

					<dd>På denne måten trenger vi bare å skrive:</dd>
					<dd><code>[bruker@pc ~]$ mount /cdrom</code></dd>

					<dt>mkfs -t < filsystem > < enhet ></dt>
					<dd>Brukes til å formatere en harddisk eller diskett. Eks. på formatering av diskett (1.4"):</dd>
					<dd><code>[bruker@pc ~]$ mkfs -t ext2 /dev/fd0 1440</code></dd>

					<dt>fsck < disk ></dt>
					<dd>Sjekker om en disk inneholder feil. Kan minne veldig om chkdsk eller scandisk i DOS. NB! Ikke kjør denne kommandoen på en disk som allerede er mountet! Hvis du trenger å sjekke en disk som mountes under oppstart (root "/" f.eks.), bør du startet opp Linux fra en oppstartdiskett og kjøre fsck fra den.</dd>
					<dd><code>[bruker@pc ~]$ fsck /dev/hdb1</code></dd>

					<dt>ps</dt>
					<dd>Viser en liste over alle prosesser som kjører. "ps ax | less" gir den komplette listen over prosesser som kjøres. For å finne ett spesifikt programs PID kan det f.eks. skrives: "ps -ax | grep netscape". Her er ett lite utdrag fra en "ps -ax" kommando:</dd>
					<dd>
<pre class="fss">
[bruker@pc ~]$ ps -ax
PID TTY   STAT   TIME   COMMAND 
 609 ?     S     0:00   /usr/X11R6/bin/xdm -nodaemon
 622 ?     S     0:44   /etc/X11/X -auth /usr/X11R6/lib/X11/xdm/authdir/authf
 873 ?     S     0:00   -:0                                                 
8099 ?     S     0:08   /local/ssh/sbin/sshd
8123 ?     S     0:00   /local/X11R6/bin/xdm -config /local/X11R6/lib/X11/xdm
8201 ?     S<    0:16   /local/sbin/xntpd -p /etc/xntpd.pid
9237 ?     S     0:00   su
9241 ?     S     0:00   bash 
9439 ?     S     0:00   mysqld
9440 ?     S     0:02   mysqld
9441 ?     S     0:00   mysqld
9497 ?     S     0:00   /opt/apache/bin/httpd
9498 ?     S     0:00   /opt/apache/bin/httpd
9499 ?     S     0:00   /opt/apache/bin/httpd
</pre>
					</dd>
					<dt>kill < pid ></dt>
					<dd>Hvis du vil avslutte ett program på en litt mindre human måte, kan det drepes ("killes"). For å kille ett program, må vi vite hva slags PID (Prosess ID) det har. Dette finner du v.h.a. kommandoen ps. Hvis ett program har sluttet å oppføre seg skikkelig (hengt seg el.l.) kan det drepes rått og brutalt: "kill -9 < pid >"</dd>
				</dl>
			</div>
		</section>
		<section>
			<div class="row">
				<dl>
					<dt>shutdown</dt>
					<dd>Ett vanlig Linux-system skal aldrig bare slåes rett av. Den må "kjøres ned". Dette gjøres ved bruk av kommandoen shutdown. For å reboot en Linux maskin brukes kommandoen:</dd>
					<dd>
						<dl>
							<dt>For å slå av en Linux maskin brukes kommandoen:</dt>
							<dd><code>[bruker@pc ~]$ shutdown -r now</code></dd>

							<dt>På en vanlig flerbruker server kan vi gi brukerene litt tid til å logge av maskinen:</dt>
							<dd><code>[bruker@pc ~]$ shutdown -h +60</code></dd>
						</dl>
					</dd>
					<dd>På større systemer med mange brukere er det vanlig at melding om nedkjøring av en server gis flere dager i forveien. Du kan også legge melding om det i filen /etc/motd, på denne måten vil alle som logger seg inn få beskjed. Denne kommandoen har flere bruksmåter, se man sidene for mer informasjon.</dd>

					<dt>fdisk < enhet ></dt>
					<dd>Brukes til å partitionere om harddisk. Se "man fdisk" for mer om bruken av fdisk.</dd>

					<dt>dmesg</dt>
					<dd>Viser all informasjon som kernelen spyttet ut under oppstart. Prøve å skriv:</dd>
					<dd><code>[bruker@pc ~]$ dmesg > oppstart</code></dd>
					<dd>Vi har nå en fil kalt "oppstart", med all oppstarts-data som kernelen viste.</dd>

					<dt>pwconv</dt>
					<dd>Hvis shadow ikke er aktivert, er passordet (kryptert), lesbart for alle. Dette er som oftest ingen god idé. Ved å skjule passordet i den restriktige filen shadow, har vi sikret oss mot det. For å deaktivere shadow, bruker vi pwunconv.</dd>
				</dl>
				<h2>grep</h2>
<pre class="fss">
Usage: grep [OPTION]... PATTERN [FILE]...
Search for PATTERN in each FILE.
Example: grep -i 'hello world' menu.h main.c

Pattern selection and interpretation:
  -E, --extended-regexp     PATTERN is an extended regular expression
  -F, --fixed-strings       PATTERN is a set of newline-separated strings
  -G, --basic-regexp        PATTERN is a basic regular expression (default)
  -P, --perl-regexp         PATTERN is a Perl regular expression
  -e, --regexp=PATTERN      use PATTERN for matching
  -f, --file=FILE           obtain PATTERN from FILE
  -i, --ignore-case         ignore case distinctions
  -w, --word-regexp         force PATTERN to match only whole words
  -x, --line-regexp         force PATTERN to match only whole lines
  -z, --null-data           a data line ends in 0 byte, not newline
Miscellaneous:
  -s, --no-messages         suppress error messages
  -v, --invert-match        select non-matching lines
  -V, --version             display version information and exit
      --help                display this help text and exit
Output control:
  -m, --max-count=NUM       stop after NUM selected lines
  -b, --byte-offset         print the byte offset with output lines
  -n, --line-number         print line number with output lines
      --line-buffered       flush output on every line
  -H, --with-filename       print file name with output lines
  -h, --no-filename         suppress the file name prefix on output
      --label=LABEL         use LABEL as the standard input file name prefix
  -o, --only-matching       show only the part of a line matching PATTERN
  -q, --quiet, --silent     suppress all normal output
      --binary-files=TYPE   assume that binary files are TYPE;
                            TYPE is 'binary', 'text', or 'without-match'
  -a, --text                equivalent to --binary-files=text
  -I                        equivalent to --binary-files=without-match
  -d, --directories=ACTION  how to handle directories;
                            ACTION is 'read', 'recurse', or 'skip'
  -D, --devices=ACTION      how to handle devices, FIFOs and sockets;
                            ACTION is 'read' or 'skip'
  -r, --recursive           like --directories=recurse
  -R, --dereference-recursive likewise, but follow all symlinks
      --include=FILE_PATTERN  search only files that match FILE_PATTERN
      --exclude=FILE_PATTERN  skip files and directories matching FILE_PATTERN
      --exclude-from=FILE     skip files matching any file pattern from FILE
      --exclude-dir=PATTERN   directories that match PATTERN will be skipped.
  -L, --files-without-match  print only names of FILEs with no selected lines
  -l, --files-with-matches  print only names of FILEs with selected lines
  -c, --count               print only a count of selected lines per FILE
  -T, --initial-tab         make tabs line up (if needed)
  -Z, --null                print 0 byte after FILE name
</pre>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<h2><strong class="fll">6</strong> sed</h2>
<pre class="fss">
Usage: sed [OPTION]... {script-only-if-no-other-script} [input-file]...

  -n, --quiet, --silent
                 suppress automatic printing of pattern space
  -e script, --expression=script
                 add the script to the commands to be executed
  -f script-file, --file=script-file
                 add the contents of script-file to the commands to be executed
  --follow-symlinks
                 follow symlinks when processing in place
  -i[SUFFIX], --in-place[=SUFFIX]
                 edit files in place (makes backup if SUFFIX supplied)
  -l N, --line-length=N
                 specify the desired line-wrap length for the `l' command
  --posix
                 disable all GNU extensions.
  -E, -r, --regexp-extended
                 use extended regular expressions in the script (for portability use POSIX -E).
  -s, --separate
                 consider files as separate rather than as a single, continuous long stream.
      --sandbox
                 operate in sandbox mode.
  -u, --unbuffered
                 load minimal amounts of data from the input files and flush the output buffers more often
  -z, --null-data
                 separate lines by NUL characters
      --help     display this help and exit
      --version  output version information and exit
</pre>
				<h2>cut</h2>
<pre class="fss">
Usage: cut OPTION... [FILE]...
Print selected parts of lines from each FILE to standard output.

With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -b, --bytes=LIST        select only these bytes
  -c, --characters=LIST   select only these characters
  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter
  -f, --fields=LIST       select only these fields; 
                          also print any line that contains no delimiter character, unless the -s is specified
  -n                      (ignored)
      --complement        complement the set of selected bytes, characters or fields
  -s, --only-delimited    do not print lines not containing delimiters
      --output-delimiter=STRING  use STRING as the output delimiter the default is to use the input delimiter
  -z, --zero-terminated    line delimiter is NUL, not newline
      --help     display this help and exit
      --version  output version information and exit
</pre>
			</div>
		</section>
		<section>
			<div class="row">
				<h2>sort</h2>
<pre class="fss">
Usage: sort [OPTION]... [FILE]...
  or:  sort [OPTION]... --files0-from=F
Write sorted concatenation of all FILE(s) to standard output.

With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
Ordering options:

  -b, --ignore-leading-blanks  ignore leading blanks
  -d, --dictionary-order      consider only blanks and alphanumeric characters
  -f, --ignore-case           fold lower case to upper case characters
  -g, --general-numeric-sort  compare according to general numerical value
  -i, --ignore-nonprinting    consider only printable characters
  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'
  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)
  -n, --numeric-sort          compare according to string numerical value
  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)
      --random-source=FILE    get random bytes from FILE
  -r, --reverse               reverse the result of comparisons
      --sort=WORD             sort according to WORD:
                                general-numeric -g, human-numeric -h, month -M,
                                numeric -n, random -R, version -V
  -V, --version-sort          natural sort of (version) numbers within text

Other options:
      --batch-size=NMERGE   merge at most NMERGE inputs at once;
                            for more use temp files
  -c, --check, --check=diagnose-first  check for sorted input; do not sort
  -C, --check=quiet, --check=silent  like -c, but do not report first bad line
      --compress-program=PROG  compress temporaries with PROG;
                              decompress them with PROG -d
      --debug               annotate the part of the line used to sort,
                              and warn about questionable usage to stderr
      --files0-from=F       read input from the files specified by
                            NUL-terminated names in file F;
                            If F is - then read names from standard input
  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type
  -m, --merge               merge already sorted files; do not sort
  -o, --output=FILE         write result to FILE instead of standard output
  -s, --stable              stabilize sort by disabling last-resort comparison
  -S, --buffer-size=SIZE    use SIZE for main memory buffer
  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition
  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or /tmp;
                              multiple options specify multiple directories
      --parallel=N          change the number of sorts run concurrently to N
  -u, --unique              with -c, check for strict ordering;
                              without -c, output only the first of an equal run
  -z, --zero-terminated     line delimiter is NUL, not newline
      --help     display this help and exit
      --version  output version information and exit
</pre>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section class="w4">
			<div class="row">
				<h2>tr</h2>
<pre class="fss">
Usage: tr [OPTION]... SET1 [SET2]
Translate, squeeze, and/or delete characters from standard input,
writing to standard output.

  -c, -C, --complement    use the complement of SET1
  -d, --delete            delete characters in SET1, do not translate
  -s, --squeeze-repeats   replace each sequence of a repeated character
                            that is listed in the last specified SET,
                            with a single occurrence of that character
  -t, --truncate-set1     first truncate SET1 to length of SET2
      --help     display this help and exit
      --version  output version information and exit

SETs are specified as strings of characters.  Most represent themselves.
Interpreted sequences are:

  \NNN            character with octal value NNN (1 to 3 octal digits)
  \\              backslash
  \a              audible BEL
  \b              backspace
  \f              form feed
  \n              new line
  \r              return
  \t              horizontal tab
  \v              vertical tab
  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order
  [CHAR*]         in SET2, copies of CHAR until length of SET1
  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0
  [:alnum:]       all letters and digits
  [:alpha:]       all letters
  [:blank:]       all horizontal whitespace
  [:cntrl:]       all control characters
  [:digit:]       all digits
  [:graph:]       all printable characters, not including space
  [:lower:]       all lower case letters
  [:print:]       all printable characters, including space
  [:punct:]       all punctuation characters
  [:space:]       all horizontal or vertical whitespace
  [:upper:]       all upper case letters
  [:xdigit:]      all hexadecimal digits
  [=CHAR=]        all characters which are equivalent to CHAR
</pre>
				<h2>Kode eksempler</h2>
				<dl>
					<dt>Finn de 20 ordene som forekommer færrest antall ganger i en tekstfil.</dt>
					<dd class="fss"><code>tr -sc a-zA-Z "\n" < churchill.txt | tr A-Z a-z | sort | uniq -c | sort -n | tr -s ' ' ' ' | head -20</code></dd>
					
					<dt>Finn de 20 ordene som forekommer færrest antall ganger i en tekstfil, skal også funke for ord med æøå i seg.</dt>
					<dd class="fss"><code>tr -sc a-zA-ZæøåÆØÅ "\n" < kongen_2008.txt | tr A-ZÆØÅ a-zæøå | sort | uniq -c | sort -n | tr -s ' ' ' ' | head -20</code></dd>

					<dt>Lag script som:</dt>
					<dd>Ber bruker om navnet på en tekstfil, leser et filnavn F fra tastaturet og lagrer dette i en skallvariabel.</dd>
					<dd>Ber bruker om et positivt heltall N, leser og lagrer også dette tallet.</dd>
					<dd>Skriver ut de N mest brukte ordene på filen F.</dd>
					<dd>
<pre class="fss">read -p "Filnavn: " F
read -p "Positivt heltakk: " N

tr -sc a-zA-Z "\n" < $F | tr A-Z a-z | sort | uniq -c
| sort - | tr -s ' ' ' ' | head -$N
</pre>
					</dd>
					<dd>

					<dt>Sorterer teksten (persondata.txt) slik at linjene blir liggende sortert i omvendt (avtagende) rekkefølge
					på personenes alder. Personer med samme alder skal ligge sortert i stigende rekkefølge på postnummer. Den
					sorterte utskriften fra kommandoen skal lagres på en fil med navn persondata_sortert.txt.</dt>
<pre class="fss">
29:Jan:HÃ¸iberg:Darres gate 22:0175:Oslo:69215348
62:Mette:Myhrvold:Sandakerveien 10G:0743:Oslo:99106353
29:Ottar:Fjernvalg:Gata 13:2222:Rena:22232425
39:Rick:Danko:Tinker Street 10:1121:Bearsville:20102010
...
</pre>
					</dd>
					<dd><code>sort -t : -k1nr -k5n < persondata.txt -o persondata-sortert.txt</code></dd>
				</dl>
			</div>
		</section>
		<section class="w6">
			<div class="row">
				<dl>
					<dt>Lag en ny fil med navn telefonliste.txt. Den nye filen skal ha like mange linjer som den opprinnelige filen.
					Hver linje på den nye filen skal inneholde (i rekkefølge) en persons fornavn, etternavn og telefonnummer, med
					tegnet : (kolon) mellom hvert datafelt. En linje på filen telefonliste.txt kan se slik ut: Jan:Høiberg:69215348
					Filen telefonliste.txt skal være alfabetisk sortert på etternavnet.</dt>
					<dd><code>cut -d: -f2,3,7 persondata.txt | sort -t: -k2 -o telefonliste.txt</code></dd>

					<dt>Les persondata.txt og bare skriv ut fornavn og etternavn (med tegnet : i mellom), for alle personer som
					har et postnummer som begynner med sifrene 11, 12 eller 13. Du kan anta at et postnummer alltid inneholder
					fire siffer</dt>
					<dd><code>egrep '\&lt;1[1-3][0-9]{2}\&gt;' persondata.txt | cut -d: -f2,3</code></dd>

					<dt>Les persondata.txt og lag en ny fil med navn persondata_2.txt. Den nye filen skal inneholde samme
					informasjon som persondata.txt, med unntak av at informasjon om alle personer som har et postnummer som begynner
					med sifrene 11, 12 eller 13 ikke skal være med på filen.</dt>
					<dd><code>egrep -v '\&lt;1[1-3][0-9]{2}\&gt;' persondata.txt > persondata_2.txt</code></dd>

					<dt>Skriv ut bare de tegnene fra /dev/urandom som er "printable". Output skal splittes opp i linjer, slik at
					det er 16 tegn på hver linje som skrives ut (se man fold). Det skal skrives ut 20 linjer med output.</dt>
					<dd><code>tr -cd '[:print:]' < /dev/urandom | fold -w 16 | head -20</code></dd>

					<dt>Generer 20 tilfeldige tall. Hvert tall skal ha nøyaktig 16 sifre. Tallene skal inneholde sifrene 0-9, men
					kan ikke begynne med sifferet 0 (null). Kommandoen skal skrive ut hvert tall på en egen linje.</dt>
					<dd><code>tr -cd '[:digit:]' < /dev/urandom | fold -w 16 | egrep '^[^0][0-9]{15}' | head -n20</code></dd>

					<dt>Skriv ut antall hop, enten helt frem til en gitt server, eller frem til første ruter på veien som kjører
					en brannvegg som "kaster" data fra traceroute.</dt>
					<dd><code>traceroute xdh.no | egrep '[[:digit:]]{1,2}[[:space:]]{2}(\* \* \*)' | head -n1 | egrep -o '[[:digit:]]{1,2}</code></dd>

					<dt>lag shellscript som leser følgende data interaktivt fra bruker: en URL, et ord og et filnavn</dt>
					<dd>Marker alle forekomster i teksten av ordet som bruker har angitt, med en * (stjerne) foran og bak ordet.</dd>
					<dd>Lagre hele teksten (med det angitte ordet markert med stjerner) på en ny fil med det angitte filnavnet.</dd>
					<dd>
<pre class="fss">
#!/bin/bash

read -p "URL: " url
read -p "Ord: " word
read -p "Filnavn: " filename

wget -O $filename $url

sed -i 's/'$word'/*'$word'*/g' $filename
</pre>
					</dd>
				</dl>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<dl>					
					<dt><h2><strong class="fsl">7</strong> if</h2></dt>
					<dd>Brukes for å starte en if check</dd>
					<dd><code>if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi</code></dd>
					<dd>
						<table class="table-code">
							<tbody>
								<tr>
									<td>[ -a FILE ]	</td>
									<td>True if FILE exists.</td>
								</tr>
								<tr>
									<td>[ -b FILE ]	</td>
									<td>True if FILE exists and is a block-special file.</td>
								</tr>
								<tr>
									<td>[ -c FILE ]	</td>
									<td>True if FILE exists and is a character-special file.</td>
								</tr>
								<tr>
									<td>[ -d FILE ]	</td>
									<td>True if FILE exists and is a directory.</td>
								</tr>
								<tr>
									<td>[ -e FILE ]	</td>
									<td>True if FILE exists.</td>
								</tr>
								<tr>
									<td>[ -f FILE ]	</td>
									<td>True if FILE exists and is a regular file.</td>
								</tr>
								<tr>
									<td>[ -g FILE ]	</td>
									<td>True if FILE exists and its SGID bit is set.</td>
								</tr>
								<tr>
									<td>[ -h FILE ]	</td>
									<td>True if FILE exists and is a symbolic link.</td>
								</tr>
								<tr>
									<td>[ -k FILE ]	</td>
									<td>True if FILE exists and its sticky bit is set.</td>
								</tr>
								<tr>
									<td>[ -p FILE ]	</td>
									<td>True if FILE exists and is a named pipe (FIFO).</td>
								</tr>
								<tr>
									<td>[ -r FILE ]	</td>
									<td>True if FILE exists and is readable.</td>
								</tr>
								<tr>
									<td>[ -s FILE ]	</td>
									<td>True if FILE exists and has a size greater than zero.</td>
								</tr>
								<tr>
									<td>[ -t FD ]	</td>
									<td>True if file descriptor FD is open and refers to a terminal.</td>
								</tr>
								<tr>
									<td>[ -u FILE ]	</td>
									<td>True if FILE exists and its SUID (set user ID) bit is set.</td>
								</tr>
								<tr>
									<td>[ -w FILE ]	</td>
									<td>True if FILE exists and is writable.</td>
								</tr>
								<tr>
									<td>[ -x FILE ]	</td>
									<td>True if FILE exists and is executable.</td>
								</tr>
								<tr>
									<td>[ -O FILE ]	</td>
									<td>True if FILE exists and is owned by the effective user ID.</td>
								</tr>
								<tr>
									<td>[ -G FILE ]	</td>
									<td>True if FILE exists and is owned by the effective group ID.</td>
								</tr>
								<tr>
									<td>[ -L FILE ]	</td>
									<td>True if FILE exists and is a symbolic link.</td>
								</tr>
								<tr>
									<td>[ -N FILE ]	</td>
									<td>True if FILE exists and has been modified since it was last read.</td>
								</tr>
								<tr>
									<td>[ -S FILE ]	</td>
									<td>True if FILE exists and is a socket.</td>
								</tr>
								<tr>
									<td>[ FILE1 -nt FILE2 ]	</td>
									<td>True if FILE1 has been changed more recently than FILE2, or if FILE1 exists and FILE2 does not.</td>
								</tr>
								<tr>
									<td>[ FILE1 -ot FILE2 ]	</td>
									<td>True if FILE1 is older than FILE2, or is FILE2 exists and FILE1 does not.</td>
								</tr>
								<tr>
									<td>[ FILE1 -ef FILE2 ]	</td>
									<td>True if FILE1 and FILE2 refer to the same device and inode numbers.</td>
								</tr>
								<tr>
									<td>[ -o OPTIONNAME ]</td>
									<td>True if shell option "OPTIONNAME" is enabled.</td>
								</tr>
								<tr>
									<td>[ -z STRING ]</td>
									<td>True of the length if "STRING" is zero.</td>
								</tr>
								<tr>
									<td>[ -n STRING ] or [ STRING ]</td>
									<td>True if the length of "STRING" is non-zero.</td>
								</tr>
								<tr>
									<td>[ STRING1 == STRING2 ]</td>
									<td>True if the strings are equal. "=" may be used instead of "==" for strict POSIX compliance.</td>
								</tr>
								<tr>
									<td>[ STRING1 != STRING2 ]</td>
									<td>True if the strings are not equal.</td>
								</tr>
								<tr>
									<td>[ STRING1 < STRING2 ]</td>
									<td>True if "STRING1" sorts before "STRING2" lexicographically in the current locale.</td>
								</tr>
								<tr>
									<td>[ STRING1 > STRING2 ]</td>
									<td>True if "STRING1" sorts after "STRING2" lexicographically in the current locale.</td>
								</tr>
								<tr>
									<td>[ ARG1 OP ARG2 ]</td>
									<td>"OP" is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if "ARG1" is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to "ARG2", respectively. "ARG1" and "ARG2" are integers.</td>
								</tr>
								<tr>
									<td><strong>Kombinering</strong></td>
									<td>Expressions may be combined using the following operators, listed in decreasing order of precedence (viktighet):</td>
								</tr>
								<tr>
									<td>[ ! EXPR ]	</td>
									<td>True if EXPR is false.</td>
								</tr>
								<tr>
									<td>[ ( EXPR ) ]	</td>
									<td>Returns the value of EXPR. This may be used to override the normal precedence of operators.</td>
								</tr>
								<tr>
									<td>[ EXPR1 -a EXPR2 ]	</td>
									<td>True if both EXPR1 and EXPR2 are true. && can also be used.</td>
								</tr>
								<tr>
									<td>[ EXPR1 -o EXPR2 ]	</td>
									<td>True if either EXPR1 or EXPR2 is true. || can also be used.</td>
								</tr>
								<tr>
									<td><strong>Eks</strong></td>
									<td></td>
								</tr>
							</tbody>
						</table>
					</dd>
					<dd class="clear">
						<div class="fl w5">
							<strong>Sjekk om en fil finnes</strong>
<pre class="fss">
#!/bin/bash
if [ -f /tmp/messages.txt ]; then
	# file exists
else
	# file does not exists
fi
</pre>
						</div>
						<div class="fl w5">
							<strong>Sjekk om en bash option er satt (set -o [OPTIONNAME])</strong>
<pre class="fss">
#!/bin/bash
if [ $USER == 'bob' ] || [ $USER == 'andy' ]
	# user is bob or andy
else
	# user is neither bob nor andy
fi
</pre>
						</div>
					</dd>
				</dl>
			</div>
		</section>
		<section>
			<div class="row">
				<dl>
					<dt><h2>Case</h2></dt>
					<dd><code>case EXPRESSION in CASE1) COMMAND-LIST;; CASE2) COMMAND-LIST;; ... CASEN) COMMAND-LIST;; esac</code></dd>
					<dd class="clear">
						<div class="fl w5">
<pre class="fss">
case $1 in
    hello)
        # $i is "hello"
        ;;
    9[1-3]) # <--- Regex
        # $i is 91, 92 or 93
        ;;
    *)
        # $i is non of the above
        ;;
esac
</pre>
						</div>
						<div class="fl w5">
							<strong>Gjør om fra timer til sec/min ved: bashfil -s/-m < timer ></strong>
<pre class="fss">
error() { exit 1; }

while getopts ":s:m:" o; do
    case "${o}" in
        s)
            tid=$((${OPTARG}*60*60))
            ;;
        m)
            tid=$((${OPTARG}*60))
            ;;
        *)
            error
            ;;
    esac
done
</pre>
						</div>
					</dd>

					<dt><h2>While loop</h2></dt>
					<dd><code>while CONTROL-COMMAND; do CONSEQUENT-COMMANDS; done</code></dd>
					<dd class="clear">
						<div class="fl w5">
							<strong>Echo hello 4 ganger</strong>
<pre class="fss">
i="0"
while [ $i -lt 4 ]; do
	echo "hello"
	((i++))
done
</pre>
<pre class="fss">
Kan også skrives uten ((i++)) inni loopen:
while [[ i++ -lt 4 ]];
</pre>
						</div>
						<div class="fl w5">
							<strong>Lag en ny fil hvert 5. min</strong>
<pre class="fss">
while true; do
	touch filename-'date +%s'.txt
	sleep 300
done
</pre>
						</div>
						<hr>
					</dd>

					<dt><h2>For in loop</h2></dt>
					<dd></dd>
					<dd class="clear">
						<div class="fl w5">
							<strong>Output alle filer & kataloger</strong>
<pre class="fss">
for i in $( ls -a ); do
	echo $i
done
</pre>
						</div>
						<div class="fl w5">
							<strong>Loop fra 1 til 10</strong>
<pre class="fss">
for i in $(seq 1 10); do
	echo $i;
done
</pre>
<pre class="fss">
Alternativt kan man skrive:
for i in {1..10}; do
</pre>
						</div>
						<hr>
					</dd>

					<div class="clear">
						<div class="fl w5 br">
							<dt><h2>Until loop</h2></dt>
							<dd></dd>
							<dd>
								<strong>Tell fra 20 til 10</strong>
<pre class="fss">
i=20
until [  $i -lt 10 ]; do
	echo i $i
	((i--))
done
</pre>
								<hr>
							</dd>
						</div>
					</div>
				</dl>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<h1><strong class="fsl">8</strong> Ord og utrykk</h1>
				<dl>
					<dt>Working directory</dt>
					<dd>Den filkatalogen bruker står i, eller programmet/prosessen er i</dd>
				</dl>
				<p>TODO</p>
				<p><a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html">http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html</a></p>
				<p><a href="https://stackoverflow.com/questions/16483119/example-of-how-to-use-getopts-in-bash">https://stackoverflow.com/questions/16483119/example-of-how-to-use-getopts-in-bash</a></p>
				<p><a href="https://stackoverflow.com/questions/14447406/bash-shell-script-check-for-a-flag-and-grab-its-value">https://stackoverflow.com/questions/14447406/bash-shell-script-check-for-a-flag-and-grab-its-value</a></p>
			</div>
		</section>
		<section>
			<div class="row">
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<h1><strong class="fsl">...</strong>Regex</h1>
				<table class="table-code">
					<thead>
						<tr>
							<th>Character</th>
							<th>Meaning</th>
							<th>Example</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>*</td>
							<td>Match <strong>zero, one or more</strong> of the previous</td>
							<td><code>Ah*</code> matches "<code>Ahhhhh</code>" or "<code>A</code>"</td>
						</tr>
						<tr>
							<td>?</td>
							<td>Match <strong>zero or one</strong> of the previous</td>
							<td><code>Ah?</code> matches "<code>Al</code>" or "<code>Ah</code>"
						</tr>
						<tr>
							<td>+</td>
							<td>Match <strong>one or more</strong> of the previous</td>
							<td><code>Ah+</code> matches "<code>Ah</code>" or "<code>Ahhh</code>" but not "<code>A</code>"</td>
						</tr>
						<tr>
							<td>\</td>
							<td>Used to <strong>escape</strong> a special character</td>
							<td><code>Hungry\?</code> matches "<code>Hungry?</code>"</td>
						</tr>
						<tr>
							<td>.</td>
							<td>Wildcard character, matches <strong>any</strong> character</td>
							<td><code>do.*</code> matches "<code>dog</code>", "<code>door</code>", "<code>dot</code>", etc.</td>
						</tr>
						<tr>
							<td>( )</td>
							<td><strong>Group</strong> characters</td>
							<td>See example for <code>|</code></td>
						</tr>
						<tr>
							<td>[ ]</td>
							<td>Matches a <strong>range</strong> of characters</td>
							<td>
								<code>[cbf]ar</code> matches "car", "bar", or "far"<br />
								<code>[0-9]+</code> matches any positive integer</br />
								<code>[a-zA-Z]</code> matches ascii letters a-z (uppercase and lower case)<br />
								<code>[^0-9]</code> matches any character not 0-9.
							</tr>
						</tr>
						<tr>
							<td>|</td>
							<td>Matche previous <strong>OR</strong> next character/group</td>
							<td><code>(Mon)|(Tues)day</code> matches "Monday" or "Tuesday"</td>
						</tr>
						<tr>
							<td>{  }</td>
							<td>Matches a specified <strong>number of occurrences</strong> of the previous</td>
							<td>
								<code>[0-9]{3}</code> matches "315" but not "31"<br />
								<code>[0-9]{2,4}</code> matches "12", "123", and "1234"<br />
								<code>[0-9]{2,}</code> matches "1234567..."
							</td>
						</tr>
						<tr>
							<td>^</td>
							<td><strong>Beginning</strong> of a string. Or within a character range <code>[]</code> negation.</td>
							<td><code>^http</code> matches strings that begin with http, such as a url.<br /><code>[^0-9]</code> matches any character not 0-9.</td>
						</tr>
						<tr>
							<td>$</td>
							<td><strong>End</strong> of a string.</td>
							<td><code>ing$</code> matches "exciting" but not "ingenious"</td>
						</tr>
					</tbody>
				</table>
				<table class="table-code">
					<thead>
						<tr>
							<th>Character Class</th>
							<th>Meaning</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>[:alpha:]</td>
							<td>Any letter, <code>[A-Za-z]</code></td>
						</tr>
						<tr>
							<td>[:upper:]</td>
							<td>Any uppercase letter, <code>[A-Z]</code></td>
						</tr>
						<tr>
							<td>[:lower:]</td>
							<td>Any lowercase letter, <code>[a-z]</code></td>
						</tr>
						<tr>
							<td>[:digit:]</td>
							<td>Any digit, <code>[0-9]</code></td>
						</tr>
						<tr>
							<td>[:alnum:]</td>
							<td>Any alphanumeric character, <code>[A-Za-z0-9]</code></td>
						</tr>
						<tr>
							<td>[:xdigit:]</td>
							<td>Any hexadecimal digit, <code>[0-9A-Fa-f]</code></td>
						</tr>
						<tr>
							<td>[:space:]</td>
							<td>A tab, new line, vertical tab, form feed, carriage return, or space</td>
						</tr>
						<tr>
							<td>[:blank:]</td>
							<td>A space or a tab.</td>
						</tr>
						<tr>
							<td>[:print:]</td>
							<td>Any printable character</td>
						</tr>
						<tr>
							<td>[:punct:]</td>
							<td>Any punctuation character: <code>! ' # S % &amp; ' ( ) * + , - . / : ; &lt; = &gt; ? @ [ / ] ^ _ { | } ~</code></td>
						</tr>
						<tr>
							<td>[:graph:]</td>
							<td>Any character defined as a printable character except those defined as part of the space character class</td>
						</tr>
						<tr>
							<td>[:word:]</td>
							<td>Continuous string of alphanumeric characters and underscores.</td>
						</tr>
						<tr>
							<td>[:ascii:]</td>
							<td>ASCII characters, in the range: 0-127</td>
						</tr>
						<tr>
							<td>[:cntrl:]</td>
							<td>Any character not part of the character classes: <code>[:upper:], [:lower:], [:alpha:], [:digit:], [:punct:], [:graph:], [:print:], [:xdigit:]</code></td>
						</tr> 
					</tbody> 
				</table>
			</div>
		</section>
		<section>
			<div class="row">
			</div>
		</section>
	</div>
</body>
</html>